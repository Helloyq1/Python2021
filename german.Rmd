---
title: "German_credit"
author: "Yuqing"
date: "2021/3/28"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    math: katex
---

# Methods of evaluation of classifiers

* Intro to statistical learning (aka Machine Learning)
* Splitting dataset into train and validation subsets
* Assessing model performance

```{r}
# The seed for generating random numbers, the seed is to make the result repeatable and reproduce the result. 
# If not, the random number generated cannot be reproduced.
set.seed(10)
```

### Loading the DATASET from URL
```{r}
DATA_SET = read.fwf("http://archive.ics.uci.edu/ml/machine-learning-databases/statlog/german/german.data-numeric", widths = rep(4, 25), header = FALSE)
DATA_SET[1, ]
```
```{r}
# V25 is our terget variable
names(DATA_SET)[25] = "target"  #是否违约，-1是，-2否
DATA_SET$target = DATA_SET$target - 1 #recoding target variable
```


### Splitting into train(80%) and validation(20%) subsets - easier version
```{r}
rand = sample(1:nrow(DATA_SET), 0.8*nrow(DATA_SET))  # 随机取80%
train = DATA_SET[rand, ]
val = DATA_SET[-rand, ]
```

### Unbalanced Dataset
```{r}
table(DATA_SET$target) 
```

### Cost-based approach to assessing the model 基于成本的方法评估模型
```{r}
CalculateCost = function(cut.off, cost.matrix, score, true.y){
  prediction = ifelse(score > cut.off, 1, 0)
  confusion.matrix = prop.table(table(factor(prediction, levels=c(0,1)),
                                      treu.y))
  return(sum(cost.matrix * confusion.matrix))
}
```

### Building logistic regression model建立逻辑回归模型

    g(X) = ㏑[p(X)/1-p(X)] = β0 + β1X
    
```{r}
x=seq(-6, 6, 0.1)
plot(x, 1/(1+exp(-x)), ylab = "Sigmoid function")
score = costs = list()
model = glm(target ~ ., data = train, family = binomial())
```
### Measuring model performance (cost-based) for different cutoof thresholds and with or without validation dataset
```{r}
CUT_OFFS = seq(0.5, 1, by=0.01)
BAD_CREDIT_COST = 5
LOST_CLIENT_COST = 1
COST_MATRIX = matrix(c(0, BAD_CREDIT_COST, LOST_CLIENT_COST, 0), 2)
```


### On validation data
```{r}
score[[1]] = predict(model, newdata = set$validation, type = "response")
costs[[1]] = sapply(CUT_OFFS, CalculateCost, cost.matrix = COST_MATRIX,
                    score = score[[1]], true.y = DATA_SET$val$target)
```










































































